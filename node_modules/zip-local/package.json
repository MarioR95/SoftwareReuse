{
  "_from": "zip-local",
  "_id": "zip-local@0.3.4",
  "_inBundle": false,
  "_integrity": "sha1-4pMZByV6lGR56lvQ0OIK3+srWgc=",
  "_location": "/zip-local",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "zip-local",
    "fetchSpec": "latest",
    "name": "zip-local",
    "raw": "zip-local",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/zip-local/-/zip-local-0.3.4.tgz",
  "_shasum": "e2931907257a946479ea5bd0d0e20adfeb2b5a07",
  "_spec": "zip-local",
  "_where": "/home/dom/Desktop/SoftwareReuse/src",
  "author": {
    "email": "mostafa.3210@gmail.com",
    "name": "Mostafa Samir"
  },
  "bugs": {
    "url": "https://github.com/Mostafa-Samir/zip-local/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "async": "^1.4.2",
    "graceful-fs": "^4.1.3",
    "jszip": "^2.5.0",
    "q": "^1.4.1"
  },
  "deprecated": false,
  "description": "very simple zipping/uzipping of local files and directories in node.js",
  "devDependencies": {
    "chai": "^3.2.0",
    "mocha": "^2.3.0",
    "rimraf": "^2.4.3"
  },
  "directories": {
    "lib": "libs",
    "test": "tests"
  },
  "homepage": "https://github.com/Mostafa-Samir/zip-local#readme",
  "keywords": [
    "async",
    "compression",
    "jszip",
    "sync",
    "unzip",
    "zip",
    "zip-local"
  ],
  "license": {
    "type": "MIT",
    "url": "https://github.com/Mostafa-Samir/zip-local/blob/master/LICENSE"
  },
  "main": "main.js",
  "name": "zip-local",
  "optionalDependencies": {},
  "readme": "# zip-local\n\n## Why another one?!\n\nI was working on a project and I needed something to zip and unzip local directories, so I went and searched on npm. I got quite a lot of results and all of them worked perfectly with files, but it when it came to directories each of them suffered from at least one of these three problems:\n* not being asynchronous\n* not being developer-friendly\n* having odd behaviors (like zipping the whole path to root along with the directory)\n\nSo I wrote this to provide something free of the three problems!\n\n## Installation\n\nusing npm:\n```\nnpm install zip-local\n```\n\n## Usage\n\nThe API comes in two versions: an asynchrnous version and a synchronous one. This gives you the choice to use whichever suitable for your application.\n\n### Zipping\n\nZipping is done through <code>ZipLocal.zip</code> or its synchronous version <code> ZipLocal.sync.zip</code> by passing the path to the file or directory that needs to be zipped. In the asynchrnous version, the callback is passed an instance of <code> ZipExport</code> object that contains the APIs to export the\nzipped file. In the synchronous version, the <code>ZipExport</code> object is returned.\n\nHere's an example of asynchronous zipping,\n\n```javascript\nvar zipper = require(\"zip-local\");\n\n// zipping a file\nzipper.zip(\"./hello-world.cpp\", function(error, zipped) {\n\n    if(!error) {\n        zipped.compress(); // compress before exporting\n\n        var buff = zipped.memory(); // get the zipped file as a Buffer\n\n        // or save the zipped file to disk\n        zipped.save(\"../package.zip\", function(error) {\n            if(!error) {\n                console.log(\"saved successfully !\");\n            }\n        });\n    }\n});\n```\n\nand here's synchronous zipping,\n\n```javascript\nvar zipper = require('zip-local');\n\n// zipping a file to memory without compression\nvar buff = zipper.sync.zip(\"./hello-world.java\").memory();\n\n// zipping a directory to disk with compression\n// the directory has the following structure\n// |-- hello-world.txt\n// |-- cpp\n//     |-- hello-world.cpp\n// |-- java\n//     |--hello-world.java\nzipper.sync.zip(\"./hello/world/\").compress().save(\"pack.zip\");\n```\n\n### Unzipping\n\nSimiliarly, unzipping is done through <code>ZipLocal.unzip</code> or the synchronous <code>ZipLocal.sync.unzip</code> by passing the path to the zip file. Like the zipping functions, these functions also use the <code>ZipExport</code> object for exporting your unzipped file, but in case of exporting in memory the <code>memory</code> function returns a <code>ZippedFS</code> object instead of a buffer. This objects servers as a mini-filesystem for the unzipped file.\n\nAn example for asynchronous unzipping,\n\n```javascript\nvar zipper = require('zip-local');\n\nzipper.unzip(\"../package.zip\", function(error, unzipped) {\n\n    if(!error) {\n        // extract to the current working directory\n        unzipped.save(null, function() { });\n\n        var unzippedfs = unzipped.memory();\n\n        // print an array of file paths in the unzipped file\n        console.log(unzippedfs.contents()); // prints [ 'hello-world.cpp' ]\n\n        // read the file as text\n        var txt = unzippedfs.read(\"hello-world.cpp\", 'text');\n\n        // or read it as Buffer\n        var buff = unzippedfs.read(\"hello-world.cpp\", 'buffer');\n    }\n});\n```\n\nand the synchronous unzipping,\n\n```javascript\nvar zipper = require('zip-local');\n\n// extract to an existing directory\nzipper.sync.unzip(\"pack.zip\").save(\"../../hello\");\n\n// export in memory\nvar unzippedfs = zipper.sync.unzip(\"pack.zip\").memory();\n\n// logs ['hello-world.txt', 'cpp/hello-world.cpp', 'java/hello-world.java']\nconsole.log(unzippedfs.contents());\n\n// read file in buffer\nvar buff = unzippedfs.read(\"cpp/hello-world.cpp\", \"buffer\");\n```\n\n### Zipping/Unzipping directly from memory\n\nImagine a serevr that needs to zip files it receives through its clients and send the zipped file to the client. When the file is received it resides in a buffer in memory, and to be able to zip it with the library (using the methods described so far) we must first save the file to local storage then zip it using its path so that the library would read it back to memory and zip it. This is definitely ineffcient and wasteful of the serevr's time and resources.\n\nTo solve this issue, starting from v0.2.0 you can zip/unzip a file directly from the buffer containing it in memory or zip an entire <code>ZippedFS</code> object from a previously unzipped file. This could be done simply by passing the bufferto the zip/unzip methods or the <code>ZippedFS</code> object to zip method instead of the path, and it works for both asynchronous and synchronous versions. Notice that in the case of zipping a buffer you'll need to pass an extra argument after the buffer which is the name of the file that will be included in the zip.\n\nHere's an example implementing the above scenario that utilizes the ability to zip buffers :\n\n```javascript\nvar zipper = require('zip-local');\nvar net = require('net');\n\nvar server = net.createServer(function (socket) {\n\n    socket.on('data', function(data) {\n\n        zipper.zip(data, \"remote_file\", function(error, zipped) {\n\n            if(error) {\n                console.log(\"ERROR: %s\", error.message);\n                return;\n            }\n\n            // cache a copy of the zipped file on the server\n            zipped.save(\"zipped_from\" + socket.remoteAddress + \".zip\", function(error) {\n                if(error) {\n                    console.log(\"ERROR: %s\", error.message);\n                    return;\n                }\n            });\n\n            // send the zipped file back to the client\n            socket.write(zipped.memory());\n        });\n    });\n});\n\nserver.listen(3000);\n```\n\n### Low Level Operations\n\nWhile the library was designed to provide a simple high-level APIs to zip/unzip local directories and files, it's sometimes needed to perform some low level operations on the data before exporting it like adding new files to the zip or removing some files form an unzipped file before writing to disk. And since this library is based on JSZip which provides these low level operations, starting from v0.2.0 you can access the underlying <code>JSZip</code> object and all its low level features through the method <code>ZipExport#lowLevel()</code>. After you zip/unzip your data and acquire the <code>ZipExport</code> object, you can call this method from it and retrieve the underlying <code>JSZip</code> object and play around with it.\n\nHere's an example that utilizes the low level operations to remove files and also utilizes the ability to zip <code>ZippedFS</code> object. This code cleans zipped files from executables (namely .exe, .bat, and .sh):\n\n```javascript\nvar zipper = require('zip-local');\n\nzipper.unzip('package.zip', function(error, unzipped) {\n\n    if(error) {\n        console.log(\"ERROR: %s\", error.message);\n        return;\n    }\n\n    var unzippedFS = unzipped.memory();\n    var files = unzippedFS.contents();\n    var notExecRegExp = new RegExp(/^[^.]+$|\\.(?!(sh|exe|bat)$)([^.]+$)/);\n\n    files.forEach(function (file) {\n        if(!notExecRegExp.test(file))\n            unzipped.lowLevel().remove(file);\n    });\n\n    var cleanUnzippedFS = unzipped.memory();\n\n    // re-zip the clean ZippedFS\n    zipper.zip(cleanUnzippedFS, function(zipped) {\n\n        zipped.save(\"package.zip\", function(error) {\n            if(error) {\n                console.log(\"ERROR: %s\", error.message);\n            }\n            else {\n                console.log(\"The file is scanned and cleaned of executables\");\n            }\n        });\n    });\n});\n```\nread the [API documentations](https://github.com/Mostafa-Samir/zip-local/wiki/API-Documentation) for furthur details.\n\n## License\n\n### MIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Mostafa-Samir/zip-local.git"
  },
  "scripts": {
    "posttest": "node ./tests/cleanup.js",
    "pretest": "node ./tests/cleanup.js",
    "test": "mocha ./tests/*.test.js"
  },
  "version": "0.3.4"
}
